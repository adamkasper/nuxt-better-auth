---
title: API Protection
description: Protect server API routes with authentication and authorization.
---

This guide covers API-specific protection patterns. For general route protection including pages, see [Route Protection](/core-concepts/route-protection).

## Basic Protection

Use `requireUserSession` to protect any API route:

```ts [server/api/user/profile.ts]
export default defineEventHandler(async (event) => {
  const { user } = await requireUserSession(event)
  return { name: user.name, email: user.email }
})
```

## Field Matching

Require specific user field values:

```ts [server/api/admin/report.ts]
const session = await requireUserSession(event, {
  user: { role: 'admin' }
})
```

Use arrays for OR logic:

```ts [server/api/admin/report.ts]
const session = await requireUserSession(event, {
  user: { role: ['admin', 'moderator'] }
})
```

## Custom Rule Callback

For complex logic, use a typed callback:

```ts [server/api/admin/report.ts]
const session = await requireUserSession(event, {
  rule: ({ user, session }) => {
    return user.role === 'admin' || user.teamRole === 'owner'
  }
})
```

The `user` and `session` parameters are fully typed based on your `auth.config.ts` plugins.

## Combining Options

Field matching and custom rules can be combined:

```ts [server/api/admin/report.ts]
const session = await requireUserSession(event, {
  user: { emailVerified: true },
  rule: ({ user }) => user.subscriptionActive
})
```

## Advanced Patterns

### Protecting GraphQL Endpoints

```ts [server/api/graphql.ts]
import { createYoga } from 'graphql-yoga'

export default defineEventHandler(async (event) => {
  const session = await getUserSession(event)

  const yoga = createYoga({
    context: { session } // Pass session to resolvers
  })

  return yoga.handle(event.node.req, event.node.res)
})
```

### Protecting WebSocket Handlers

```ts [server/api/ws.ts]
import { defineWebSocketHandler } from 'h3'

export default defineWebSocketHandler({
  open: async (peer) => {
    const event = peer.ctx.event
    await requireUserSession(event, { user: { role: 'member' } })
  },
  message(peer, message) {
    // handle message
  }
})
```

### Rate Limiting Authenticated Routes

```ts [server/api/expensive-operation.ts]
const rateLimiter = new Map<string, number>()

export default defineEventHandler(async (event) => {
  const { user } = await requireUserSession(event)

  const lastCall = rateLimiter.get(user.id)
  if (lastCall && Date.now() - lastCall < 60000) {
    throw createError({ statusCode: 429, message: 'Rate limited' })
  }

  rateLimiter.set(user.id, Date.now())
  return performExpensiveOperation()
})
```

## CSRF Protection

Better Auth includes CSRF protection by default for state-changing operations. Ensure you:

1. Use the auth client methods (not raw `fetch`)
2. Don't disable CSRF in production
3. Include credentials in fetch requests

```ts
// ✓ Correct: uses auth client
await client.signIn.email({ email, password })

// ✗ Incorrect: bypasses CSRF protection
await fetch('/api/auth/sign-in/email', {
  method: 'POST',
  body: JSON.stringify({ email, password })
})
```

:read-more{to="/core-concepts/security-caveats" title="Security Caveats"}
